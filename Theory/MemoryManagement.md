# Memory Management

## Terminologies

* **Logical Address:** Logical or Virtual Address is generated by the CPU.
* **Logical Address Space:** The set of all Logical Addresses generated by a Program. 
* **Physical Address:** An Address actually available on memory Unit.
* **Logical Address Space:** The set of all physical Addresses corresponding to the logical Address. 

## Fragmentation
Fragmentation is defined as when the process is loaded and removed after execution from memory, it creates a small free hole. These holes can not be assigned to new processes because holes are not combined or do not fulfill the memory requirement of the process. There are two types of Fragmentation.

* **Internal Fragmentation:** Internal fragmentation occurs when memory blocks are allocated to the process more than their requested size. Due to this some unused space is leftover and creates an internal fragmentation problem.

* **External Fragmentation:** In external fragmentation, we have a free memory block, but we can not assign it to process because blocks are not contiguous.

## Contiguous Memory Allocation
In Contiguous memory Allocation, each Process is allocated a single contiguous segment of Memory.

### Fixed Partion
In Fixed Partitioning, the Memory is divided into partitions of equal sizes. Each Process is allocated these Partions as per the requirement. No two processes share the same Partition. The maximum number of Processes that can exist in Fixed Partioning is equal to the total number of Partions present in the main Memory.

Fixed Partioning suffers from the effects of Internal and External Fragmentation. It puts a limit on the Process size and also the degree of Multi-Programming i.e., number of simultanoeous Process that can exist in the main Memory at a given time. Few methods through which Fixed Partioning tries to allocate memory are as follows:

* **First Fit:** The First availabe free hole that fulfills the Memory requirement of the process is allocated.
* **Best Fit:** The Smallest availabe free hole that fulfills the Memory requirement of the process is allocated.
* **Worst Fit:** The Largest availabe free hole that fulfills the Memory requirement of the process is allocated.

### Variable Partion
In Variable Partitioning, Processes are allocated memory as per the need one after another in a contiguous fashion. It overcomes the issue of Internal Framgnetation and limit on Multi-Programming. However, it too suffers from External Fragmentation. Further, Memory allocation and de-allocation is complex and time-consuming. 

## Non-Contiguous Memory Allocation
Non-contiguous memory Allocation allows Processes to be allocated whereever there is space in the Main memory.

### Paging

The process of retrieving processes in the form of pages from the secondary storage into the main memory is known as paging. The basic purpose of paging is to separate each procedure into pages. Additionally, frames will be used to split the main memory. This scheme permits the physical address space of a process to be non – contiguous.

Paging maps logical addresses to Physical address. The page size is equal to the Frame Size. The number of entires in the Page table is equal to the number of pages in the logical address space. The Page table entry contains the frame number. All page tables of the processes are placed in the Main Memory.

The Mapping from Virtual to Physical Address is done by the Memory Management Unit (MMU). 

* The Physical Address Space is divided conceptually into a number of Fixed size blocks, called Frames.
* The Logical Address Space is split into fixed-size blocks called Pages. The page size is equal to the Frame size.

The CPU allocates the Logical address to a Process. The Logical address consists of the Page number and the Page offset. The page offset corresponds to the offset within a frame in the Physical Memory. The MMU uses the page Number to fetch the frame number from the Page table. Then, the frame number together with the offset constitutes the Physical Addresss within the Main Memory.

### Multi-Level Paging
Multilevel Paging is a paging scheme that consists of two or more levels of page tables in a hierarchical manner. It is also known as hierarchical paging. The entries of the level 1 page table are pointers to a level 2 page table and entries of the level 2 page tables are pointers to a level 3 page table and so on. The entries of the last level page table store actual frame information. Level 1 contains a single-page table and the address of that table is stored in PTBR (Page Table Base Register).

#### Why is it required?

* The size of the Page table itself is greater than the frame size. This means it needs to be split between multiple frames to be able to store it in the Main Memory.

#### Example

**Consider a System using Paging Scheme where:**

* **Logical Address Space = 4GB**
* **Physical Address Space = 16TB**
* **Page size = 4KB**

Number of bits requred to represent Physical Memory = 16TB =  $2^{44}$ bytes.

Number of bits requred to represent Logical Memory = 2GB = $2^{32}$ bytes.

Frame size = page size = 4KB = $2^{12}$ bytes.

Total number of Frames in Physical Memory = $16TB/4KB$ = $2^{44}/2^{12}$ = $2^{32}$

Hence, 32 bits are required to represent the frame number. Thus, each entry or page in the page table will take 32 bits.

Total number of Pages required for the Process = $2^{32}/2^{12}$ = $2^{20}$

Hence, total size of Page table = $4$ bytes $*2^{20}$ = $2^{22}$ = 4MB

Thus, number of frames required to store the page table = $2^{22}/2^{12}$ = $2^{10}$

Hence, the page table cannot be stored in a single Frame thus requiring Multi-level Paging.

--------------------------------------------------------------------------------------------------

For the seconday Page table,

Number of pages to store = $2^{10}$

Frame size = 4 bytes

Total size of secondary page table = $4 * 2^{10}$ = 4KB

Since, this page table can fit into a single frame, hence we require two-level paging to represent the Logical Address Space.


### Inverted Paging
Most Operating Systems implement a separate page table for each process, i.e. for ‘n’ number of processes running on a Multiprocessing/ Timesharing operating system, there is ‘n’ number of page tables stored in the memory. Sometimes when a process is very large in size and it occupies virtual memory then with the size of the process, its page table size also increases substantially.

An alternate approach is to use the Inverted Page Table structure that consists of a one-page table entry for every frame of the main memory. So the number of page table entries in the Inverted Page Table reduces to the number of frames in physical memory and a single page table is used to represent the paging information of all the processes. This technique is called inverted paging as the indexing is done with respect to the frame number instead of the logical page number. Each entry in the page table contains the following fields.

* **Page Number:** It specifies the page number range of the logical address.
* **Process ID:** An inverted page table contains the address space information of all the processes in execution. Since two different processes can have a similar set of virtual addresses, it becomes necessary in the Inverted Page Table to store a process Id of each process to identify its address space uniquely. 
* **Control Bits:** These bits are used to store extra paging-related information. These include the valid bit, dirty bit, reference bits, protection, and locking information bits.
* **Chanined Pointer:**  It may be possible sometimes that two or more processes share a part of the main memory. In this case, two or more logical pages map to the same Page Table Entry then a chaining pointer is used to map the details of these logical pages to the root page table.

### Segmentation

Paging divides a process into equal partitions namely pages. However, Segmentation divides a Process into unequal parts corresponding to the User view or logic of the Program. It uses Segmentation table to convert Logical address to Physical Address.

The Segmentation table consists of the Base address and size of the segment which corresponds to the actual Physical address and the total memory size of the Segment respectively. 

Whenever, the CPU generates a logical address, the segment bits are used to identify the segment to extract the base Physical address from the Segment table and the offset bit represent the data location with respect to the base address. The MMU checks if the offset is less than or equal to the size of the segment. If the CPU tries to access a location beyond the segment size, it raises a TRAP interrupt. Otherwise, the offset is added to the base address to determine the actual physical address of the data location.

#### Advantages

* As a complete module is loaded all at once, segmentation improves CPU utilization.
* Segmentation provides a higher degree of flexibility than paging. Segments can be of variable size, and processes can be designed to have multiple segments, allowing for more fine-grained memory allocation.
* Segmentation allows for sharing of memory segments between processes. This can be useful for inter-process communication or for sharing code libraries.
* Segmentation provides a level of protection between segments, preventing one process from accessing or modifying another process’s memory segment. This can help increase the security and stability of the system.

### Segmented Paging

In Segmented Paging, the main memory is divided into variable size segments which are further divided into fixed size pages.

* Pages are smaller than segments.
* Each Segment has a page table which means every program has multiple page tables.
* The logical address is represented as Segment Number (base address), Page number and page offset.

#### Structure of Logical Address

* **Segment Number:**  It points to the appropriate Segment Number.
* **Page Number:**  It points to the exact page within the segment.
* **Page Offset:**  Used as an offset within the page frame.

## Thrashing

When multiple Process executes, the OS tries to store all the Pages of the Processes into the Main Memory. However, if the number of Processes are high, then the Main Memory fails to keep all the Pages into RAM and it shifts some of the Pages to Seconday Memory. 

Thus, when the CPU demands a Page that is not present in the Main Memory, Page fault occurs. Whenever a page fault occurs, the OS tries to fetch that page from the Secondary Memory and tries to swap it with one of pages in RAM. This process is called Swapping.

Thrashing happens when the page fault and swapping happens very frequently causing the CPU to spend most of the time swapping these pages rather than processing Application-level instructions. This reduces CPU Utilization and thus, degrades throughput.

Hence, when we increase degree of Multi-programming i.e., number of active Processes, there is an optimal value at which the throughput is maximum, after which the OS starts thrashing and the throughput decays down.